1.-
(define empty ?
( lambda (l)
(if (zero?(length l))
True
False)))
Ğ“â”œ l: list
Ğ“â”œ (length(list<- num))
Ğ“â”œ(length l): num
Ğ“â”œ(zero?(length l)):bool Ğ“â”œTrue:bool Ğ“â”œFalse:bool
(define fib
(lambda (n)
(cond
[(zero?n) 1]
[( = n 1) 1]
[ (+( fib(- n 1)) (fib (- n 2)))])))
Ğ“â”œn:num Ğ“â”œn:num Ğ“â”œ1:num
Ğ“â”œ (zero?n):bool Ğ“â”œ1:number Ğ“â”œ(- n 1):bool Ğ“â”œ1:num Ğ“â”œ(+â€¦): number
Ğ“(n<-number) â”œ(cond[â€¦]): number
Ğ“(fib<-number) â”œ((lambda(n:number)): number (cond[â€¦])):number->number
2.- Tenemos las siguientes restricciones
[[ 1 ]]=(+ 1 ( first (cons true empty))) â†’ [[ 2 ]]
[[ 1 ]]â†’ number
[[ 2 ]]=(first (cons true empty))â†’ [[ 3 ]]
[[ 3 ]]= (cons ( true empty))
Pero [ true] = Boolean !
Ya que [[ 1 ]] es number por la definiciÃ³n de + por lo cual la expresiÃ³n [[ 1 ]] no puede sumar
boolean y number. Eso por un erro de tipos.
3.-
[[ 1 ]] = (fun (f : (1) : (2
(fun (x: (3) : (4
(fun (y : (5) : (6
(cons x (f(f y)))))) â†’ [[ 2 ]]
[[ 2 ]]= (fun (x: (3) : (4
(fun (y : (5) : (6
(cons x (f(f y))))) â†’ [[ 3 ]]
[[ 3 ]]= (fun (y : (5) : (6
(cons x (f(f y)))) â†’ [[ 4 ]]
[[ 4 ]] =(cons x (f(f y)))
por ğ‘“ğ‘¦â†’ [ f ]= type(y)
por [[ 4 ]]â†’[[ğ¶6]]=y
En [[ 3 ]] por [[ 4 ]] y por el juicio de tipos en funciones
[[ ğ¶5 ]]â†’ y
Entonces [y]=type(y)
CÃ³mo [[ 2 ]]â†’[[ 3 ]] entonces [[ ğ¶4 ]]= type(y)
Por juicio de tipo en funciones:
[[ ğ¶4 ]]â†’x y x=type(y)
Por ultimo por juicio de tipo en [[ 1 ]]
[[ 1 ]]â†’ type(y) ya que ğ¶2=type(x)=type(y)
4.- No cambian por que sirven para revisar que los tipos sean correctos en la funciÃ³n.
5.-
ExplÃ­cito:
Ventajas
Buen mantenimiento y reutilizaciÃ³n de cÃ³digo.
Desventajas:
CÃ³digo extenso, el tipo de las referencias dan muchos limitantes y las variables a las que se pueden
acceder.
ImplÃ­cito:
Ventajas:
Poco cÃ³digo y no necesita un cast explicito.
Desventajas:
Se puede llegar a desconocer el tipo y pueden salir incongruencias.
6.-
General
Ventajas:
Posee bibliotecas
Puede usarse para distintos problemas
Pueden hallarse mÃºltiples soluciones
Desventajas:
Soluciones poco eficaces o difÃ­ciles de comprender.
EspecÃ­fico:
Ventajas:
Soluciones optimas
FÃ¡cil de intuir
Soluciones menos complejas
Desventajas:
Fuera de su dominio es inÃºtil.
Ejemplos:
C no es eficaz con objetos, pues no posee orientaciÃ³n a estos. 
#include <stdio.h> 
int main() { 
int c, n, fact = 1; 
printf("Enter a number to calculate it's factorial\n"); s
canf("%d", &n); 
for (c = 1; c <= n; c++) 
fact = fact * c; 
printf("Factorial of %d = %d\n", n, fact);
return 0; }
Haskell se limita a ser un programa lÃ³gico. 
factorial 0 = 1 factorial n = n * factorial (n - 1)
Sql a modelar y trabajar con bases de datos.
Select fact From factorial where nidfact=0
